<html>
<head>
<title>TLB</title>
<style>
</style>
<link rel = "stylesheet" type = "text/css" href = "index.css"/>
</head>
<body>
<h1>Translation Look-Aside Buffer</h1>
<p>The basic method for implementing paging involves breaking physical memory
into fixed-sized blocks called frames and breaking logical memory into
blocks of the same size called pages. When a process is to be executed, its
pages are loaded into any available memory frames from their source (a file
system or the backing store). The backing store is divided into fixed-sized
blocks that are the same size as the memory frames or clusters of multiple
frames. This rather simple idea has great functionality and wide ramifications.
For example, the logical address space is now totally separate fromthe physical
address space, so a process can have a logical 64-bit address space even though
the system has less than 264 bytes of physical memory.</br></br>
Every address generated by the CPU is divided into two parts: a page number (p) and a page offset (d). The page number is used as an index into a page table. The page table contains the base address of each page in physical memory. This base address is combined with the page offset to define the physical memory address that is sent to the memory unit.
If the size of the logical address space is 2m, and a page size is
2n bytes, then the high-order m−n bits of a logical address designate the page
number, and the n low-order bits designate the page offset.</br></br>

<u><b>Problem</b></u></br>
The problem with this approach is the time required to access a user
memory location. If we want to access location i, we must first index into
the page table, using the value in the PTBR offset by the page number for i. This
task requires a memory access. It provides us with the frame number, which
is combined with the page offset to produce the actual address. We can then
access the desired place in memory. With this scheme, two memory accesses
are needed to access a byte (one for the page-table entry, one for the byte). Thus,
memory access is slowed by a factor of 2. This delay would be intolerable under
most circumstances. We might as well resort to swapping!</br></br>

<u><b>Solution</b></u></br>
The standard solution to this problem is to use a special, small, fast lookup
hardware cache called a translation look-aside buffer (TLB). Each entry in the TLB consists of two parts: a key (or tag) and a value. When the associative memory is presented with an item, the item is compared with all keys simultaneously. If the item is found, the corresponding value field is returned. The search is fast; a TLB lookup in modern hardware is part of the instruction pipeline, essentially adding no
performance penalty. To be able to execute the search within a pipeline step,
however, the TLB must be kept small. It is typically between 32 and 1,024 entries
in size. Some CPUs implement separate instruction and data address TLBs. That
can double the number of TLB entries available, because those lookups occur
in different pipeline steps. We can see in this development an example of the
evolution of CPU technology: systems have evolved from having no TLBs to
having multiple levels of TLBs, just as they have multiple levels of caches.
The TLB is used with page tables in the following way. The TLB contains
only a few of the page-table entries. When a logical address is generated by the
CPU, its page number is presented to the TLB. If the page number is found, its
frame number is immediately available and is used to access memory. As just
mentioned, these steps are executed as part of the instruction pipeline within
the CPU, adding no performance penalty compared with a system that does
not implement paging.
If the page number is not in the TLB (known as a TLB miss), a memory
reference to the page table must be made. Depending on the CPU, this may be
done automatically in hardware or via an interrupt to the operating system.
When the frame number is obtained, we can use it to access memory. In addition, we add the page number and frame number to the TLB, so that they will be found quickly on the next reference. If the TLB is already full of entries, an existing entry must be selected for replacement. Replacement policies range from least recently used (LRU) through round-robin to random. Some CPUs allow the operating system to participate in LRU entry replacement, while others handle the matter themselves. Furthermore, some TLBs allow certain entries to be wired down, meaning that they cannot be removed from the TLB. Typically, TLB entries for key kernel code are wired down.
An
ASID uniquely identifies each process and is used to provide address-space
protection for that process. When the TLB attempts to resolve virtual page
numbers, it ensures that the ASID for the currently running process matches the
ASID associated with the virtual page.</br>

Effective Memory Access Time = ( (Hit Percentage * TLB Access Time) + (Miss Percentage * Main memory Access Time) ) .</br></br>

One additional bit is generally attached to each entry in the page table: a
valid–invalid bit. When this bit is set to valid, the associated page is in the
process's logical address space and is thus a legal (or valid) page. When the
bit is set to invalid, the page is not in the process's logical address space. Illegal
addresses are trapped by use of the valid–invalid bit. The operating system
sets this bit for each page to allow or disallow access to the page.
</br></br>
Just like cache TLB can also have two level / multi-level TLB to improve performance. 
</p>
</body>
</html>
